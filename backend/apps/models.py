from django.db import models
from django.contrib.auth.models import AbstractUser
from django.utils.translation import gettext_lazy as _
from django.core.exceptions import ValidationError
from django_countries.fields import CountryField
from enumfields import EnumField  # Install django-enumfields for robust enums
from datetime import datetime


# ===========================
# 1. Custom User Model
# ===========================

class User(AbstractUser):
    """
    Custom user model for InvestWise Predictor.
    Extends the default Django User model with additional fields.
    """
    class RiskTolerance(models.TextChoices):
        LOW = 'L', _('Low')
        MODERATE = 'M', _('Moderate')
        HIGH = 'H', _('High')

    phone_number = models.CharField(max_length=15, blank=True, null=True)
    date_of_birth = models.DateField(blank=True, null=True)
    risk_tolerance = EnumField(RiskTolerance, max_length=1, default=RiskTolerance.MODERATE)

    def __str__(self):
        return self.username


# ===========================
# 2. Core Models
# ===========================

class Prediction(models.Model):
    """
    Represents an investment prediction generated by the AI model.
    """
    class Status(models.TextChoices):
        PENDING = 'P', _('Pending')
        PROCESSING = 'PR', _('Processing')
        COMPLETED = 'C', _('Completed')
        FAILED = 'F', _('Failed')

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='predictions')
    sector = models.CharField(max_length=255, help_text="The industry or sector being analyzed.")
    country = CountryField()  # Use django-countries for country selection
    predicted_value = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    status = EnumField(Status, max_length=2, default=Status.PENDING)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def clean(self):
        """
        Custom validation logic for the Prediction model.
        """
        if not self.sector:
            raise ValidationError("Sector field is required.")
        if not self.country:
            raise ValidationError("Country field is required.")

    def save(self, *args, **kwargs):
        """
        Override the save method to perform additional actions.
        """
        self.full_clean()  # Perform validation before saving
        super().save(*args, **kwargs)

    def __str__(self):
        return f"Prediction for {self.user.username} - {self.sector} ({self.country})"


class DataPoint(models.Model):
    """
    Represents a single data point used for analysis.
    """
    indicator = models.CharField(max_length=255, help_text="The type of economic indicator (e.g., GDP, inflation).")
    value = models.FloatField()
    date = models.DateField()
    country = CountryField()
    source = models.CharField(max_length=255, help_text="The source of the data (e.g., World Bank, KNBS).")

    def __str__(self):
        return f"{self.indicator} ({self.country}) - {self.date}"


class InvestmentPreference(models.Model):
    """
    Stores user preferences for investments.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='investment_preference')
    preferred_sector = models.CharField(max_length=255, blank=True, null=True)
    preferred_country = CountryField(blank=True, null=True)
    risk_tolerance = EnumField(User.RiskTolerance, max_length=1, blank=True, null=True)

    def __str__(self):
        return f"Preferences for {self.user.username}"


class RiskProfile(models.Model):
    """
    Represents a user's risk profile based on their investment behavior.
    """
    class ProfileType(models.TextChoices):
        CONSERVATIVE = 'C', _('Conservative')
        BALANCED = 'B', _('Balanced')
        AGGRESSIVE = 'A', _('Aggressive')

    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='risk_profile')
    profile_type = EnumField(ProfileType, max_length=1, default=ProfileType.BALANCED)
    score = models.IntegerField(default=50, help_text="Risk score between 0 and 100.")
    description = models.TextField(blank=True, null=True)

    def __str__(self):
        return f"Risk Profile for {self.user.username}"


class Notification(models.Model):
    """
    Stores notifications sent to users.
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications')
    message = models.TextField()
    is_read = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

    def mark_as_read(self):
        """
        Marks the notification as read.
        """
        self.is_read = True
        self.save()

    def __str__(self):
        return f"Notification for {self.user.username}"


# ===========================
# 3. Supporting Models
# ===========================

class EconomicIndicator(models.Model):
    """
    Represents an economic indicator used in predictions.
    """
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    unit = models.CharField(max_length=50, help_text="Unit of measurement (e.g., %, USD).")
    source = models.CharField(max_length=255)

    def __str__(self):
        return self.name


class SectorPerformance(models.Model):
    """
    Tracks the performance of different sectors over time.
    """
    sector = models.CharField(max_length=255)
    growth_rate = models.DecimalField(max_digits=5, decimal_places=2, help_text="Growth rate (%)")
    market_size = models.DecimalField(max_digits=10, decimal_places=2, help_text="Market size (USD)")
    year = models.PositiveIntegerField(default=datetime.now().year)

    def __str__(self):
        return f"{self.sector} Performance ({self.year})"


# ===========================
# 4. Custom Managers
# ===========================

class PredictionManager(models.Manager):
    """
    Custom manager for the Prediction model.
    """
    def get_pending_predictions(self):
        """
        Returns all pending predictions.
        """
        return self.filter(status=Prediction.Status.PENDING)

    def get_completed_predictions(self):
        """
        Returns all completed predictions.
        """
        return self.filter(status=Prediction.Status.COMPLETED)


# Assign the custom manager to the Prediction model
Prediction.objects = PredictionManager()


# ===========================
# 5. Utility Functions
# ===========================

def validate_positive(value):
    """
    Validates that a value is positive.
    """
    if value <= 0:
        raise ValidationError("Value must be positive.")


class FinancialMetric(models.Model):
    """
    Base model for financial metrics with common fields.
    """
    metric_name = models.CharField(max_length=255)
    value = models.DecimalField(max_digits=10, decimal_places=2, validators=[validate_positive])
    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        abstract = True

    def __str__(self):
        return f"{self.metric_name}: {self.value}"
